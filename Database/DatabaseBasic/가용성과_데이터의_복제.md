## 가용성과 데이터의 복제
---

### 데이터베이스는 어떤 때에 크래쉬되는가
---

#### 전형적인 장애 시나리오

1. 소프트웨어 장애

2. OS 장애

3. 하드웨어 장애

4. 조작 실수

#### 디스크 이중화로 데이터 손실 방지

**RAID**
>하나의 서버에 여러 개의 HDD를 탑재하고 동일한 데이터를 두 개 이상의 HDD에 분산시키는 기술

* RAID 0(스트라이핑) 복수의 HDD에 데이터를 기록하여 읽고 쓰기를 고속화시키는 방식

* RAID 1(미러링) 두 대의 HDD에 동일 데이터를 작성하는 방식, 이용 가능 용량은 디스크 수의 절반이다.

* RAID 5 : 오류 정정 부호인 패리티 데이터와 함께 분산하여 기록하는 방식, 이용 가능 용량은 N개의 경우 N-1개가 된다.

*RAID 6 : 오류 정정 부호인 패리티를 두 개 생성하고 데이터와 함께 분산하여 기록 하는 방식, 이용 가능 용량은 N개의 경우 N-2개가 된다.

**핫 스왑**
>첫 번째 HDD가 손상된 경우에 서비스를 멈추지 않고 망가진 HDD와 새로운 HDD를 교체하여 복구하는 기술

### 복제
>현재 가장 널리 사용되고 있는 중복화 방식
---

#### 단방향 복제
>가장 전통적인 복제 방식

##### 단방향/비동기
>마스터에서 갱신한 결과가 슬레이브에 비동기로 전파하는 유형의 복제

MYSQL에서 표준으로 사용되는 복제 기능

마스터에서 실행한 갱신계의 SQL 문이 바이너리 로그라는 전용 로그 파일로 기록

슬레이브가 저장된 로그파일을 순차적으로 실행

슬레이브는 **바이너리 로그 수신**과  **바이너리 로그 실행** 이라는 2단계로 구성

마스터가 장애를 일으킨 경우 슬레이브에서 지금까지의 업데이트 결과가 반영되지 않을 수 있다.

반영되지 않는 상황은 두가지의 패턴으로 인해 일어난다.

1. 마스터에서 생성한 바이너리 로그가 슬레이브에서 마지막까지 수신되지 않은 상황
2. 슬레이브에서의 바이너리 로그의 실행이 마지막까지 종료되지 않은 상황


1은 슬레이브의 I/O 스레드가 비동기이기 때문에 발생할 수 있는 현상이다.

마스터가 이미 죽었기 때문에 슬레이브가 수신한 최종 결과와 마스터의 최종 결과 사이에 데이터가 손실될 수 있다.

이 경우 OS가 살아있으면 SSH로 접속하여 바이너리 로그를 가져오는 구제 조치가 가능하다.

2는 슬레이브의 SQL 스레드가 지연되어 일어나는 현상이다.

마스터가 죽어도 슬레이브에 저장된 바이너리 로그를 사용하면 된다.

##### 단방향/준동기화

MYSQL은 슬레이브가 바이너리 로그를 수신 -> 바이너리 로그의 내용을 실행 단계로 나누어져 있다.

새 버전의 MYSQL은 이중 1의 부분을 동기화 방식으로 할 수 있다.

이를 준동기식 복제라고 한다.

![MYSQL의 복제](http://gywn.net/wp-content/uploads/2017/06/mysql-semisync-5.7.png)

출처 : [gywndi's database](http://gywn.net/tag/semi-sync-replication/)

1이 동기 방식으로 됨으로써 마스터를 업데이트한 클라이언트는 그 결과를 마스터의 DB상에서 확정하는 것 뿐만 아니라 대상 슬레이브로 전송하여 그 확인응답이 반환될 때까지 기다리게 된다.

이 방식은 클라이언트에서 응답을 받았을 때 그 업데이트가 슬레이브에 도착해 있는 것이 보증된다.

단점은 마스터 -> 슬레이브 간의 바이너리 로그의 교환을 기다리는 동안만큼 응답 시간이 나빠진다.

#### 단방향/동기

MYSQL에서는 구현되어 있지 않지만, 슬레이브에 대해 업데이트 결과의 반영까지 마친 상태에서 처음으로 클라이언트에 응답을 반환하는 방식이다.

마스터가 장애를 일으킨 경우 슬레이브에서도 업데이트 결과가 반영되어 있기 떄문에 즉시 슬레이브에서 서비스를 재개할 수 있다.

### 양방향 복제
>마스터를 두 개 이상 갖게 하고 각각의 마스터를 업데이트 할 수 있도록 한 구성

#### 양방향 복제의 기술적 한계

DB의 업데이트가 서로 충돌하면 불일치를 낳게 되기 떄문에 분산형 배타 제어의 구조가 필요하다.

MYSQL과 같이 비동기/준동기 복제를 기반으로 한 제품에서는 배타 제어를 실현하기 어렵다.

그래서 동일 ID에 대한 업데이트를 별도의 DB 서버로 향하지 않도록 애플리케이션 로직을 제어하는 것이 필요하다.

이에 대해 여러 서버에 각각 업데이트를 할 수 있으며, 그들이 자동으로 동기화되는 구조를 가진 것이 있다.

MYSQL Cluster 라는 제품이 양방향 복제의 구조를 가지고 있다.

MYSQL Cluster는 데이터 노드라고 하는 특수 서버에서 데이터를 가지고 있다.

중복성을 위해 두 개 이상의 데이터 노드에서 동일한 데이터를 서로 보관한다.

한 데이터 노드에 적용된 업데이트는 다른 쪽 데이터 노드에 동기적으로 반영된다.

동일한 기본 키 값을 업데이트하는 경우는 동일 서버에 대해서 액세스되도록 한다.