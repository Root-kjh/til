## 트랜잭션과 무결성, 무정지성

### 트랜잭션의 필요성

사용자가 서비스를 이용하다 DB가 다운될경우이를 복구하는 작업에는 매우 큰 수고가 들어간다.

다운을 대비해 예외처리를 해준다면 코드량이 매우 증가하고 시간도 매우 오래걸릴 것이다.

이러한 수고를 모두 줄여주는 기능이 트랜잭션이다.

트랜잭션에서 하나의 기능은 다음과 같이 기술한다.

BEGIN:

UPDATE ...;

UPDATE ...;

COMMIT;

COMMIT이 실행되기 전 DB가 다운되거나 ROLLBACK을 하면 BEGIN 이후의 쿼리가 모두 무효가 된다.

### SQL문 레벨에서의 롤백

한번의 1만개의 레코드를 갱신하는 UPDATE 문을 실행하던 도중, 서버가 다운되어 8000개의 데이터만 갱신된 경우, 이를 복구하기 위해서는 엄청난 수고가 들어간다.

트랜잭션 기능을 이용해 업데이트 자체를 없던일로 하고 업데이트 쿼리를 다시 실행하면 처음 예상했던 결과가 나온다.

만약 한개의 레코드만을 갱신한다고 해도, 테이블 전체의 인덱스도 같이 갱신되기 때문에 이러한 처리 도중 DB가 다운되게 되면 DB 자체가 손상될 수 있다.

### 무정지성 확보하기

트랜잭션을 지원하지 않는 DB의 경우, OS 장애 뿐만 아니라 DB 프로세스가 비정상적으로 종료하기만 해도 DB가 손상될 수 있다.

Oracle과 InnoDB같은 트랜잭션 대응의 DB에서는 이러한 문제가 발생하지 않는다.
![무정지성을 담보하는 매처니즘](http://www.dba-oracle.com/images/oracle_redo_disk_bottlenecks.jpg)

출처 : [DBA-Oracle.com](http://www.dba-oracle.com/t_redo_log_tuning.htm)

#### REDO 로그의 역할

InnoDB에서는 트랜잭션을 커밋하면 그떄마다 LSN이라는 시퀀스 번호가 증가하고, 그 번호와 갱신 대상의 블록의 정보를 REDO 로그 파일에 쓴다.

데이터파일은 캐시 영역에 데이트롤 보관하고 정기적으로 디스크에 기록하는데, 서버 장애 등의 이류로 DB가 재가동을 하게 되는 경우 REDO 로그의 내용을 데이터 파일에 적용시켜 REDO 로그의 LSN과 일치시키는 작업을 수행한다.

### 잠금 메커니즘에 의한 베타 제어

같은 레코드에 동시 액세스가 발생할 경우 결과가 예상과 다르게 나타난다.

이를 막기 위해 정평이 나 있는 메커니즘이 잠금(LOCK)이다.

#### 잠금의 범위

InnoDB등 현대적인 RDBMS에서 확보하고 있는 잠금의 범위는 레코드다.

#### 잠금의 기간

잠금은 트랜잭션의 종료(커밋 또는 롤백) 시까지 유지한다.

#### 잠금 매커니즘의 단점

동일한 레코드에 대한 갱신이 동시에 한 개의 클라이언트밖에 할 수 없다.

예를들어

T1 : 상품 A의 주식 수를 1 감소(2->1)

T2 : 상품 A의 주식 수를 1 감소(1->0)

T1 : 소지하고 있는 돈을 감소시킨다(오류:부족)

다음과 같은 상황에서 상품 A의 재고가 잠겨 있지 않으면 원래대로 되돌리는 것은 어렵다..

여러 클라이언트에서 갱신할 수 있도록 잠금을 걸지 않고 배타 제어를 시시하는 **락 프리** 라는 알고리즘도 주목을 끌고 있다.

이 경우 충돌이 발생하더라도 일관성 있는 상태로 복원할 수 있도록 구현해야 할 필요가 있어 구현의 복잡성이 크게 향상된다.

### 복제 및 트랜잭션

#### 원자성을 갖는 복제의 중요성

슬레이브는 마스터에서 전송된 쿼리를 실행하는 역할을 한다.

슬레이브는 마스터에서 보낸 쿼리 중 어디까지를 실행했는지에 대한 정보도 관리하 필요가 있다.

그렇지 않으면 슬레이브가 멈추었을 때 어디서부터 다시 시작하면 좋은지를 알 수 없기 때문이다.

MYSQL에서는 MYSQL 5.6과 InnoDB의 경우 처음으로 원자성 있는 갱신이 가능하게 되었다.

마스터는 트랜잭션이 커밋될 때마다 갱신 SQL을 바이너리로 기록한다.

슬레이브에서는 바이너리 로그의 내용을 실행하여 나가지만, 현재 실행 위치를 관리하기 위해 실행을 마친 바이너리 로그의 위치 정보를 관리하는 InnoDB 테이블을 제공한다.

그리고 SQL 문의 실행과 위치 정보 갱신을 동일한 트랜잭션에서 실시한다.