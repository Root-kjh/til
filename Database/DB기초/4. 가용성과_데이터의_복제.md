## 가용성과 데이터의 복제
---

### 데이터베이스는 어떤 때에 크래쉬되는가
---

#### 전형적인 장애 시나리오

1. 소프트웨어 장애

2. OS 장애

3. 하드웨어 장애

4. 조작 실수

#### 디스크 이중화로 데이터 손실 방지

**RAID**
>하나의 서버에 여러 개의 HDD를 탑재하고 동일한 데이터를 두 개 이상의 HDD에 분산시키는 기술

* RAID 0(스트라이핑) 복수의 HDD에 데이터를 기록하여 읽고 쓰기를 고속화시키는 방식

* RAID 1(미러링) 두 대의 HDD에 동일 데이터를 작성하는 방식, 이용 가능 용량은 디스크 수의 절반이다.

* RAID 5 : 오류 정정 부호인 패리티 데이터와 함께 분산하여 기록하는 방식, 이용 가능 용량은 N개의 경우 N-1개가 된다.

*RAID 6 : 오류 정정 부호인 패리티를 두 개 생성하고 데이터와 함께 분산하여 기록 하는 방식, 이용 가능 용량은 N개의 경우 N-2개가 된다.

**핫 스왑**
>첫 번째 HDD가 손상된 경우에 서비스를 멈추지 않고 망가진 HDD와 새로운 HDD를 교체하여 복구하는 기술

### 복제
>현재 가장 널리 사용되고 있는 중복화 방식
---

#### 단방향 복제
>가장 전통적인 복제 방식

##### 단방향/비동기
>마스터에서 갱신한 결과가 슬레이브에 비동기로 전파하는 유형의 복제

MYSQL에서 표준으로 사용되는 복제 기능

마스터에서 실행한 갱신계의 SQL 문이 바이너리 로그라는 전용 로그 파일로 기록

슬레이브가 저장된 로그파일을 순차적으로 실행

슬레이브는 **바이너리 로그 수신**과  **바이너리 로그 실행** 이라는 2단계로 구성

마스터가 장애를 일으킨 경우 슬레이브에서 지금까지의 업데이트 결과가 반영되지 않을 수 있다.

반영되지 않는 상황은 두가지의 패턴으로 인해 일어난다.

1. 마스터에서 생성한 바이너리 로그가 슬레이브에서 마지막까지 수신되지 않은 상황
2. 슬레이브에서의 바이너리 로그의 실행이 마지막까지 종료되지 않은 상황


1은 슬레이브의 I/O 스레드가 비동기이기 때문에 발생할 수 있는 현상이다.

마스터가 이미 죽었기 때문에 슬레이브가 수신한 최종 결과와 마스터의 최종 결과 사이에 데이터가 손실될 수 있다.

이 경우 OS가 살아있으면 SSH로 접속하여 바이너리 로그를 가져오는 구제 조치가 가능하다.

2는 슬레이브의 SQL 스레드가 지연되어 일어나는 현상이다.

마스터가 죽어도 슬레이브에 저장된 바이너리 로그를 사용하면 된다.

##### 단방향/준동기화

MYSQL은 슬레이브가 바이너리 로그를 수신 -> 바이너리 로그의 내용을 실행 단계로 나누어져 있다.

새 버전의 MYSQL은 이중 1의 부분을 동기화 방식으로 할 수 있다.

이를 준동기식 복제라고 한다.

![MYSQL의 복제](http://gywn.net/wp-content/uploads/2017/06/mysql-semisync-5.7.png)

출처 : [gywndi's database](http://gywn.net/tag/semi-sync-replication/)

1이 동기 방식으로 됨으로써 마스터를