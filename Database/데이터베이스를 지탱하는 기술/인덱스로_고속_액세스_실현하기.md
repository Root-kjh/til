# 인덱스로 고속 액세스 실현하기

---

## [키와 값의 페어] 를 관리하고 싶다.

---

#### 전체 검색은 대략의 데이터에 적합하지 않다.

방대한 양의 데이터를 단순히 데이터의 처음부터 끝까지 읽으며 특정 데이터를 찾는 방법을 **선형 검색** 이라 한다.

이 방법은 검색 알고리즘에서 가장 비효율적인 방법이라 할 수 있으며, 데이터가 n배가 되면 n배의 계산량(시간) 이 걸리는 방법이다.

#### 원하는 위치까지 순식간에 도달하는 방법 생각하기.

> 사용자 정보를 **고정 길이** 으로 관리하는 기술

예를 들어 사용자 정보를 반드시 100 바이트로 관리하는 경우 **사용자 ID X 100 바이트째** 가 사용자 정보를 저장하는 시작 위치가 된다.

하지만 고정 길이 파일로 데이터를 관리해 나가는 방식은 낭비가 너무 심한 방식이다.

#### 인덱스 구조 도입하기

>각 사용자 ID 마다 파일 상의 시작 위치를 기록한 파일을 만들어 고속으로 사용자 정보를 찾는 구조

인덱스 파일은 **[키값 , 바이트 위치]** 가 구성 요소가 된다.

| 사용자 ID | 지정 장소의 위치 |
|:-------:|:-------:|
| 1 | 1번째 바이트 |
| 2 | 73번째 바이트 |
| 3 | 166번째 바이트 |

이론적으로 키 값과 바이트 위치를 Unsigned integer로 관리하면 하나의 레코드 당 8바이트를 사용한다.

예를 들어 사용자의 아이디가 100인 경우, 100*8 바이트 째를 읽으면 본체 파일의 데이터를 빠르게 읽어올 수 있다. 

이 방법은 액세스가 2번 필요하다는 단점이 존재하지만, 데이터의 양에 의존하지 않고 상당히 빠른 검색을 할 수 있다.

>만약 DB의 내용이 수정되면 인덱스도 함께 업데이트 되어야 한다.

#### 해시 인덱스

>앞의 인덱스 항목은 **[키값 , 바이트 위치]** 뿐이므로 고정 길이 포맷으로 대응할 수 있지만, 키 값의 데이터 항목은 문자열, 숫자, 날짜/시;간 등 여러가지가 들어갈 수 있으므로 더욱 더 범용성을 추구하면 고정길이로 구현하는 것이 어렵다.

실제 DB의 구현은 키값을 해시 함수에 대입하여 해시 값과 값의 쌍을 갖는 **해시 인덱스** 구조가 즐겨 사용되고 있다.

| 해시 인덱스 | 지정 장소의 위치 |
|:-------:|:-------:|
| lajhfdalihfdalisf | 1번째 바이트 |
| ohuiwer0r329ru98r | 73번째 바이트 |
| fsdhfsdioghsdfjhi | 166번째 바이트 |

해시 계산은 문자열 길이에 상관 없이 동일한 크기이므로 고정 길이 포맷으로 대응할 수 있고, 해시 계산 비용은 데이터의 양에 의존하지 않기 때문에 아무리 데이터 양이 늘어도 계산량은 변경되지 않는다.

이러한 처리의 계산량을 O(1) 이라 하며, 가장 빠른 알고리즘으로 분류된다.

>실제로 해시 인덱스를 구현하려고 하면 다른 키 값인데 같은 해시 값이 나오는 **해시 충돌** 상황이 발생한다.

>이 경우, 충돌을 감지하여 실제 일치하는지에 대한 여부를 확인하는 구조가 필요하다.

##### 해시 인덱스가 만능은 아니다.

1. 가격이 10,000원 이하의 선물
2. "Final"로 시작하는 게임 리스트

위와 같이 지정한 키 값과 같은 것이 아닌, **범위 검색** 을 하면 해시 인덱스는 키의 값이 몇개로 반환될지 사전에 알 수 없고, 실제로 검색해 보지 않으면 모른다.

이러한 해시 인덱스의 단점을 보안해주는 구조가 **B+Tree** 라고 불리는 인덱스 구조다.
## 인덱스의 기본 [B+Tree 인덱스]

---

#### B+Tree 인덱스란?

>나무 구조로 된 인덱스

정상이 **루트(root)블록**, 최하층이 **리프(leaf)블록** 이며, 그 사이에 **브랜치(branch)블록** 이 들어간다.

**루트 블록, 브랜치 블록**
>검색의 키인 사용자 ID에 대해 해당 블록이 어디에 있는지에 대한 정보를 가지고 있다.

**리프 블록**
>실제 저장위치에 대한 정보를 가지고 있다.


##### B+Tree 인덱스 구조

![B+Tree 인덱스 구조](http://wiki.gurubee.net/download/attachments/1507450/b_tree_uniqe_scan.JPG)

출처 : [구루비 DB 커뮤니티](http://wiki.gurubee.net/pages/viewpage.action?pageId=1507450)

#### 다분기 트리와 이진 트리

**이진트리**
>브랜치 및 리프의 분기 개수가 두 개밖에 없는 것

B+Tree는 분기 개수가 두 개 정도가 아닌 수십 개에서 수백 개에 걸치는 경우도 있다.

B+Tree는 다분기의 트리 구성을 취함으로써 O(logN)의 계산량이 되어 액세스 수를 크게 줄일 수 있다.

#### B+Tree와 B-Tree

**B-Tree**
>모든 ㄱ밧을 리프 블록에서만 갖도록 제한하지 않으며, 브랜치에서도 값을 가질 수 있는 데이터 구조

B+Tree는 B-Tree에 비해 어떤 값이라도 루트에서 리프까지 거치지 않으면 열의 값을 검색할 수 없다는 단점이 있다.

하지만 브랜치가 간결해 지므로 인덱스 자체의 구조를 줄여 최약의 경우 액세스 횟수를 줄일 수 있다.

## RDBMS에서는 어떻게 최적화를 실행하고 있는가?

---

#### 고유성의 보장

>데이터 관리 상황에서 중복된 정보가 없다는 것을 보증

인덱스를 고유성을 보증하는 목적으로 사용

해시 인덱스라면 동일한 ID인 경우에 반드시 동일한 해시값이 되고, B+Tree 인덱스라면 동일 리프블록에 도달하기 때문에 적은 코스트로 쉽게 중복체크를 할 수 있다.

**고유 인덱스**
>고유성이 보장된 인덱스

**비고유 인덱스**
>고유성이 보장되지 않은 인덱스

#### 멀티 칼럼 인덱스

인덱스 검색을 하는 데 있어 지정하고 싶은 조건이 한 개 이상일 수 있다.

이 경우 여러 개의 조건을 모두 검색하는 것이 효과적이다.

이러한 여러 조건의 인덱스를 **멀티 칼럼 인덱스** 라고 한다.

여러 RDBMS는 두 가지 요소를 결합한 인덱스를 만들 수 있으며, AND 조건에서 검색을 가속화 할 수 있다. 

#### 인덱스만을 읽는 검색



#### 인덱스 병합



## 업데이트 비용 절감을 위한 노력

---

#### 디스크에 모아서 기록하기



#### 병렬 갱신 성능 높이기


