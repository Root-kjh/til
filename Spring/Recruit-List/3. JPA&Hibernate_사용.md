# JPA & Hibernate
---

* 인터페이스의 모음, Hibernate에서 JPA의 인터페이스를 구현한다.

* 개발자가 JPA를 사용하면, JPA 내부에서 JDBC API를 사용하여 SQL 호출, DB와 통신한다.

### JPA & Hibernate의 장점

* SQL 중심적 개발에서 객체 중심으로 개발

* 생산성

    * 간단한 CRUD

    * 특히 수정이 굉장히 간단함

* 유지보수 : 필드 변경시 SQL의 수정이 필요없음

* 약간의 성능향상

    * 캐싱 기능

    * 트랜잭션을 지원하는 쓰기 지연

    * 지연 로딩 : find 함수가 실행될 때가 아닌 값이 실제로 필요한 시점에 JPA가 SELECT 쿼리를 날림

### JPA & Hibernate의 단점

* 세밀함 : 메서드 호출로 쿼리를 날리기 때문에 세밀함이 떨어짐

    이 점을 보완하기 위해 SQL과 유사한 기술인 JPQL 지원

    SQL 자체 쿼리도 작성할 수 있음

* 높은 러닝커브 : JPA를 잘 사용하기 위해서는 알아야 할 것이 많음

## JPA & Hibernate 사용법

    DB 관련 설정을 제외한 JPA, Hibernate의 사용법만을 기술한다.

    (MySQL Database 사용)

### 의존성 설정

```xml
        <!-- 스프링 ORM -->
        <dependency>
             <groupId>org.springframework</groupId>
             <artifactId>spring-orm</artifactId>
             <version>${org.springframework-version}</version>
        </dependency>

		<!-- JPA&Hibernate -->
        <dependency>
             <groupId>org.hibernate</groupId>
             <artifactId>hibernate-entitymanager</artifactId>
             <version>5.0.11.Final</version>
        </dependency>
```

### Context 설정

```xml
	<!-- 트랜잭션 활성화 -->
	<tx:annotation-driven/>
	
	<!-- 트랜잭션 관리자 등록 -->
	<bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">
		<property name="dataSource" ref="dataSource"/>
	</bean>
	
	<!-- JPA예외 스프링 예외로 변환 -->
	<bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/>
	
	<!-- JPA설정(엔티티 매니저 팩토리 등록) -->
	<bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
		<property name="dataSource" ref="dataSource"/>
		
		<!-- Entity 탐색 범위 -->
		<property name="packagesToScan" value="com.DrK.domain"/>
		
		<!-- Hibernate 구현체 사용 -->
		<property name="jpaVendorAdapter">
			<bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"/>
		</property>
		
		<!-- Hibernate 상세 설정 -->
        <property name="jpaProperties">
           <props>
                <prop key="hibernate.dialect">org.hibernate.dialect.MySQL5InnoDBDialect</prop> <!-- 방언 -->
                <prop key="hibernate.show_sql">true</prop>                          <!-- SQL 보기 -->
                <prop key="hibernate.format_sql">true</prop>                        <!-- SQL 정렬해서 보기 -->
                <prop key="hibernate.use_sql_comments">true</prop>                  <!-- SQL 주석 보기 -->
                <prop key="hibernate.id.new_generator_mappings">true</prop>         <!-- JPA 표준에 맞게 새로운 키 생성 전략을 사용-->
                <prop key="hibernate.hbm2ddl.auto">none</prop>
            </props>
         </property>

        <!-- service, repositories package 경로 등록 -->
        <context:component-scan base-package="com.DrK.service, com.DrK.repositories">
                <context:include-filter type="annotation"
                        expression="org.springframework.stereotype.Repository" />
                <context:include-filter type="annotation"
                        expression="org.springframework.stereotype.Service" />
                <context:include-filter type="annotation"
                        expression="org.springframework.stereotype.Component" />
        </context:component-scan>
	</bean>
```

* Entity : 테이블로 매핑 시킬 객체

* hibernate.hbm2ddl.auto 옵션 : 애플리케이션이 실행될 때 기존의 데이블을 삭제하고 새로운 테이블을 생성할지에 대한 옵션

    1. none : 기본값, 아무 일도 일어나지 않음

    2. create-only

    3. drop

    4. create

    5. create-drop : SessionFactory가 시작될 때 스키마를 drop& creat 하며, SessionFactory가 종룔될 때도 스키마를 drop함

    6. validate : 스키마 검증

    7. update : 스키마 갱신

### Entity Mapping

#### UserVO 생성

```java
package com.DrK.domain;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

import lombok.Data;

@Data
@Entity
@Table(name = "User")
public class UserVO {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private long idx;
	
	@Column(name = "id", nullable = false, length = 50)
	private String id;
	
	@Column(name="password", nullable = false, length = 65)
	private String password;
}
```

* @Entity : Entity 선언

    * Options

        1. name : JPA가 사용할 엔티티 이름 지정

* @Table : 엔티티 클래스에 매핑할 테이블 정보 명시

    * Options

        1. name : 테이블 이름

        2. schema : schema 기능이 있는 DB에서 schema Mapping

* @Id : 테이블의 기본 키(Primary Key)에 매핑

* @GenerateValue : 기본 키 생성 전략

    * Options

        1. strategy : 대리 키 사용 방식

            * AUTO : DB 종류에 따라 알맞은 것을 선택

            * IDENTITY : 기본 키 생성을 DB에 위임

                (MySQL, PostgreSQL, SQL Server, DB2)

            * SEQUENCE : DB Sequence 사용

                (Oracle, PostgreSQL, DB2, H2)

            * TABLE : 키 전용 테이블을 만들어 Sequence처럼 사용

* @Column

    * Options

        1. name : 컬럼 이름

        2. nullable : nulll 허용 여부

        3. length : 문자 길이 제약 조건

* @Temporal : 날짜 타입 매핑시 사용

    * Options

        1. TemporalType.DATE

        2. TemporalType.TIME
        
        3. TemporalType.TIMESTAMP

* @Transient : 매핑이 이루어지지 않는 객체

* @Enumerated : Java의 Enum타입 매핑시 사용

    * Options

        1. EnumType.ORDINAL

        2. EnumType.STRING

* 매핑 정보가 없을 때

    * 매핑 어노테이션을 생략하면 필드명을 그대로 칼럼명으로 매핑

### Repository 구현

```java
package com.DrK.repositories;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;

import org.springframework.stereotype.Repository;

import com.DrK.entities.User;

@Repository
public class UserRepository{

	@PersistenceContext // EntityManagerFactory가 DI 할 수 있도록 설정
	private EntityManager em;
	
	public List<User> findAll(){
		String jpql="select u from User u order by u.idx desc";
		TypedQuery<User> query=em.createQuery(jpql,User.class);
		
		return query.getResultList();
	}
}
```

### 테스트코드 작성

```java
package com.DrK.repositories;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import com.DrK.entities.User;

import lombok.Setter;
import lombok.extern.log4j.Log4j;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("file:src/main/webapp/WEB-INF/spring/root-context.xml")
@Log4j
public class UserRepositoryTest {

	@Setter(onMethod_ = @Autowired)
	private UserRepository userRepository;
	
	@Test
	public void getListTest() {
		for (User user: userRepository.findAll()) {
			log.info(user.getId());
		}
	}
}
```