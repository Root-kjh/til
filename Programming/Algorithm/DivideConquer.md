# 분할 정복

    "이것이 개발자의 각개격파다." 

    주어진 문제를 둘 이상의 부분 문제로 나눈 뒤 각 문제에 대한 답을 재귀 호출을 이용해 계산하는 알고리즘

* 분할정복의 세가지 요소

1. 문제를 더 작은 문제로 분할하는 과정
2. 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정
3. 더이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제

### 연습코드

#### 수열의 빠른 합

1부터 n까지의 합을 n개의 조각으로 나눈 뒤, 아들을 반으로 잘라 n/2 개의 조각들도 만들어진 부분 문제 2 개를 만든다.

fastSum(n) = 1+2++++n = (1+2++++2/n)((2/n+1)++++n)

첫번째 부분 문제는 fastsum(2/n)으로 나타낼수 있지만, 두번째 부분문제는 1부터 시작하지 않기 때문에 그럴 수 없다.

따라서 다음과 같이 두번째 부분 문제를 fastSum(x)를 포합하는 형태로 바꿔야 한다.

((2/n+1)+++n) = ((2/n+1)+(2/n+2)+++(2/n+2/n)) = (2/n)*(2/n)+(1+2+++2/n)

    이해가 잘 안가서 실제 숫자를 대입해 보았다.

    fastSum(10) = 1+2+3+4+5+6+7+8+9+10 = (1+2+3+4+5)(6+7+8+9+10)

    (6+7+8+9+10) = 6+7+8+9+(5+5) = 5*5+(1+2+3+4+5)

(2/n)*(2/n)+(1+2+++2/n) = (2/n)^2+fastSum(2/n)

따라서, fastSum(n) = 2*fastSum(2/n)+4/(n^2) (n이 짝수일 때)

이를 코드로 구현해 보았다.

```python
def fastSum(n):
    if n==1:
        return 1
    if n%2==1:
        return fastSum(n-1)+n
    return 2*fastSum(n/2)+(n*n/4)
```

수열의 합계를 구할땐 위의 방법이 sum(range(n))보다 훨씬 빠르다.
sum(range(n))의 시간복잡도는 O(n)인 반면, fastSum의 시간복잡도는 O(log(n))이다.

실제 가정용 컴퓨터로 10^549 까지의 수열의 합계를 구하는데에 0.01초밖에 걸리지 않았다.

#### 행렬의 빠른 제곱

    n*n의 크기의 행렬 A가 주어질 때, A의 거듭제곱 A^m을 구하는 알고리즘

기본적인 알고리즘으로는 O(n^3*m)의 연산이 필요하다.