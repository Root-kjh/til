# Big O 표기법
> 시공간 복잡도를  수학적으로 표시하는 대표적인방법(가장 최악의 경우의 시공간 복잡도를 계산한다), 인풋 데이터 증가율에 따른 알고리즘의 성능을 논리적으로 예측하기 위해 사용한다.

* O(1) (Constant)

    입력 데이터와 상관없이 언제나 일정한 시간이 걸리는 알고리즘을 나타낸다.   

* O(lon2 n) (Logarithmic)

    입력 데이터의 크기가 커질 수록 처리 시간이 로그(log: 지수 함수의 역함수) 만큼 짧아지는 알고리즘이다. 이진탐색 알고리즘이 대표적이다.

* O(n) (Linear)

    입력 데이터의 크기에 비례해 처리 시간이 증가하는 알고리즘이다. 선형 탐색 알고리즘이 대표적이다.

* O(n log2 n) (Linear-Logarithmic)

    데이터가 많아질수록 처리시간이 log배 만큼 더 늘어나는 알고리즘이다. 정렬 알고리즘 Merge sort, Quick sort의 평균 시간복잡도이다.

* O(n^2) (quadratic)

    데이터가 많아질수록 처리시간이 급수적으로 늘어나는 알고리즘이다. 이중 루프(n^2 matrix)가 대표적이다.

* O(2^n) (Exponential)

    데이터량이 많아질수록 처리시간이 기하급수적으로 늘어나는 알고리즈이다. 대표적으로 피보나치 수열이 있다.


## 시간 복잡도를 구하는 요령

* 하나의 루프를 사용하여 단일 요소 집합을 반복하는 경우 O(n)

* 컬렉션의 절반 이상을 반복 하는 경우 : O(n/2) -> O(n)

* 두 개의 다른 루프를 사용하여 두 개의 개별 컬렉션을 반복 할 경우 : O(n+m) -> O(n)

* 두 개의 중첩 루프를 사용하여 단일 컬렉션을 반복하는 경우 : O(n^2)

* 두 개의 중첩 루프를 사용하여 두 개의 다른 콜렉션을 반복 할 경우 : O(n*m) -> O(n^2)

* 컬렉션 정렬을 사용하는 경우 : O(n*log(n))

