# ProgrammingParadigm

    패러다임은 무엇을 해야할지를 말하기 보다 무엇을 해서는 안되는지에 대해 말한다.

    아래의 세가지 패러다임은 우리에게서 각각 goto문, 함수 포인터, 할당문을 앗아간다.

    이 밖에 우리에게서 가져갈수 있는 것이 없기 떄문에 프로그래밍 패러다임은 앞으로도 딱 세가지뿐일 것이다.(실제로 1958년부터 1968년에 걸친 10년동안 3가지의 패러다임이 모두 만들어졌다.)

## 구조적 프로그래밍

    구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.

구조적 프로그래밍을 개발한 데이크스트라는 증명이라는 수학적인 원리를 프로그래밍에 적용하고자 했다.

그는 유클리드 계층구조를 사용해 입등된 구조를 이용하고, 이들 구조를 코드와 결합시켜 코드가 올바르다는 사실을 스스로 증명하는 방식을 생각했다.

데이크스트라는 이 연구를 진행하면서 goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견했다. 반면 got 문장을 사용하더라도 모듈을 분해할 때 문제가 되지 않는 경우도 있었다.(if/then/else, do/while) 모듈이 이러한 종류의 제어 구조만을 사용한다면 증명 가능한 단위로까지 모듈을 세분화 하는 것이 가능해보였다.

현재는 제어흐름을 제약 없이 전환할 수 있는 선택권 자체를 언어에서 제공하지 않는다.

구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었다.

이렇게 분해한 기능들은 구조적 프로그래밍의 제한된 제어 구조를 이용하여 표현할 수 있다.

하지만 끝내 프로그램 관점에서 정리에 대한 유클리드 계층구조는 끝내 만들어지지 않았다. 대신 테스트라는 과정을 통해 만들어진 프로그램에 버그가 있음은 증명할 수 있게 되었다.

## 객체 지향 프로그래밍

    객체 지향 그로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

좋은 아키텍처를 만드는 일은 객체 지향(OO) 설계 원칙을 이해하고 응용하는 데서 출발한다.

OO의 본질을 설명하기 위해 세 가지 개념을 알아야하는데, 그것이 캡슐화(encapsulation), 상속(inheritance), 다형성(polymorphism)이다. OO는 이 세가지 개념을 적절하게 조합한 것이거나, 최소한 세가지 요소를 지원해야 한다.

#### 캡슐화

OO 언어에서는 각각 클래스의 private멤버 데이터와, public 멤버 함수로 캡슐화가 제공된다.

이를통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다.

사실 OO가 강력한 캡슐화에 의존하지는 않으며, 실제로 많은 OO 언어가 캡슐화를 거의 강제하지 않는다.

OO 프로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음을 기반으로 한다.

#### 상속

상속이란 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의 하는 일을 말한다.

#### 다형성

다형성은 함수를 가리키는 포인터를 응용한 것이다.

OO 언어는 함수 포인터를 사용할 경우 지켜야 할 수동적 관례(포인터 초기화, 포인터를 통해 모든 함수 호출)를 없애주어 다형성을 사용하는데에 있어 실수할 위험을 없애준다.

OO의 다형성을 통해 장치 독립성을 지원하는 플러그인 아키텍처를 언제 어디서든 적용할 수 있게 되었다. 

## 함수형 프로그래밍

    함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.

