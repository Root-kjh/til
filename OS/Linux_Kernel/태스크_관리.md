# 태스크 관리

* 태스크 : 자원 소유권의 단위
* 쓰레드 : 수행의 단위
* 프로세스 : 동작중인 프로그램

### 사용자 입장에서의 프로세스 구조

32bit의 운영체제는 각 프로세스에게 총 4GB 크기의 가상공간을 할당한다.

리눅스는 이중 0-3GB를 사용자 공간으로 사용하고, 나머지 3-4GB를 커널 공간으로 사용한다.
(64bit 의 경우 2^64=16EB 크기의 가상 공간 중 약 128TB의 공간을 사용자 공간으로 사용한다.)

![프로세스 구조](https://t1.daumcdn.net/cfile/tistory/2453664C5444038310)
출처 : [ORANG](http://orang.tistory.com/entry/%EB%A6%AC%EB%88%85%EC%8A%A4-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0)

프로세스는 크게 텍스트, 데이터, 스택, 힙이라는 네 영역으로 구분할 수 있다.

텍스트 영역 : CPU에서 직접 수행되는 명령어가 들어가 있다.

데이터 영역 : 전역변수가 들어가있다.

스택 영역 : 지역변수, 인자, 함수의 리턴 주소 등이 존재한다.

힙 영역 : 동적 할당받은 내용이 존재한다.

이떄 각 영역을 세그먼트 혹은 가상 메모리 객체라고 부른다.

### 리눅스의 태스크 모델

프로세스는 자신이 사용하는 자원과 그 자원에서 수행되는 수행 흐름으로 수성된다.

리눅스는 이를 관리하기 위해 task_struct라는 자료구조를 생성한다.

리눅스 커널은 프로세스 와 쓰레드 모두 task_struct로 관리한다.

![리눅스의 태스크 관리 구조](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory&fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F211BEC4C51C727FA2ED4A6)

출처 : [티스토리 블로그](http://muscle-fairy.tistory.com/m/149?category=518502)

이러한 리눅스의 특성은 실제 함수들이 구현된 방식에서도 나타난다.

![태스크 생성과 관계된 함수의 흐름](http://thumbnail.egloos.net/600x0/http://pds22.egloos.com/pds/201205/01/70/a0027070_4f9f3e585b9be.png)

출처 : [egloos 블로그](http://egloos.zum.com/hahaha333/v/3835505)

리눅스에서 사용자의 프로세스 혹은 쓰레드 생성 요청은 라이브러리를 거쳐 시스템 호출을 통해 리눅스 커널에 전달된다.

fork(), vfork(), clone(), pthread_create()는 모두 커널 내부 함수인 do_fork()를 호출한다.

이는 리눅스의 입장에서 쓰레드와 프로세스가 모두 태스크를 생성하기 때문에 가능하다.

즉, do_fork()를 호출할 때, 부모 태스크와 얼마나 공유할지를 정해 줌으로써 fork()와 clone() 함수 둘 다를 지원 할 수 있는 것이다.

#### do_fork()

do_fork() 함수는 새로 생성되는 태스크의 이름표를 준비한다(task_struct) 여기에 태스크에 대한 자세한 정보들을 기록해 둔다.

그 후 태스크에 자원 등을 할당한 뒤 수행 가능한 상태로 만든다.

#### 쓰레드와 프로세스의 차이

fork(), vfork() 함수는 각 태스크의 pid, tgid가 부모 태스크와 서로 다른 것을 알 수 있다.

즉 사용자 입장에서 서로 다른 프로세스가 만들어진 것이다.

반면 pthread_create()에서는 각 태스크의 pid는 다르지만 tgid는 같은것을 알 수 있다.

### 태스크 문맥

태스크는 task_struct 이외에도 많은 정보들이 필요한데, 태스크와 관련된 모든 정보들을 문맥(context)라고 부른다.

![태스크 문맥](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory&fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F171CE23C4F8313E533A370)

출처 : [.NET개발자](http://godffs.tistory.com/m/1446?category=123052)

태스크의 문맥은 크게 세 부분으로 나뉜다.

첫 번째 부분은 시스템 문맥으로 태스크의 정보를 유지하기 위해 커널이 할당한 자료구조들이다.

두 번째 부분은 메모리 문맥으로 텍스트, 데이터, 스택, heap 영역, 스왑 공간 등이 포함된다.

세 번째 부분은 하드웨어 문맥으로 문맥교환 할 때 태스크의 현재 실행 위치에 대한 정보를 유지하며, 실행 중이던 태스크가 대기 상태나 준비 상태로 전이할 때 이 태스크가 어디까지 실행했는지 기억해 두는 공간으로, 이후 이 태스크가 다시 실행될 때 기억해 두었던 곳부터 다시 시작하게 된다.

### task_struct
>task_struct의 변수들

##### task identification
>태스크를 인식하기 위한 변수들 (pid,tgid,해쉬 관련 필드 등), 사용자 접근 권한을 제어하는 변수들 (uid,euid,suid,fsuid 등), 사용자 그룹 접근 제어에 이용되는 변수들(gid,egid,sgid,fsgid 등) 이있다.

##### state
>태스크의 상태를 관리하기 위한 변수
> * TASK_RUNNING(0)
> * TASK_INTERRUPTIBLE(1)
> * TASK_UNINTERRUPTIBLE(2)
> * TASK_STOPPED(4)
> * TASK_TRACED(8)
> * EXIT_DEAD(16)
> * EXIT_ZOMBIE(32)

##### task relationship
> 현재 태스크를 생성한 부모 태스크의 task_struct 구조체를 가리키는 real_parent와 현재 부모 태스크의 task_struct를 가리키는 parent 필드 등이 존재한다.

![task relationship](https://images.slideplayer.com/26/8876622/slides/slide_9.jpg)

출처 : [Kernel Programming Task Management 이병희](https://slideplayer.com/slide/8876622/)

##### scheduling information
> prio,policy,cpus_allowed,time_slice,rt_priority 등 스케줄링과 관련된 변수들이 있다.

##### signal information
>시그널과 관련된 변수들이 존재한다. (시그널은 태스크에게 비동기적인 사건의 발생을 알리는 매커니즘이다.)

##### memory information
>태스크는 자신의 명령어와 데이터를 텍스트, 데이터, 스택, 힙 공간 등에 저장한다.
task_struct에는 이공간에 대한 위치와 크기, 접근 제어 정보 등을 관리하는 변수들이 존재한다.

>가상 주소를 물리 주소로 변환하기 위한 페이지 디렉터리와 페이지 테이블 등의 주소 변환 정보들이 존재한다. 이러한 정보들은 task_struct에서 mm_struct라는 이름의 변수로 접근할 수 있다.

##### file information
>태스크가 오픈한 파일들은 task_struct에서 files_struct 구ㅗ체 형태인 files라는 이름의 변수로 접근할 수 있다.

>루트 디렉터리의 inode와 현재 디렉터리의 inode는 fs_struct 구조체 형태인 fs라는 변수로 접근할 수 있다.

##### thread structure
>쓰레드 구조는 문맥 교환을 수행할 때 태스크가 현재 어디까지 실행되었는지 기억해놓는 공간이다.

##### time information
> 태스크의 시간 정보를 위한 변수, 태스크가 시작된 시간을 가리키는 start_time, real_start_time 등이 있으며, 사용한 cpu 시간의 통계를 담는 필드도 있다.

##### format
> 리눅스는 Linux exec 도메인뿐만 아니라 BSD나 SVR4 커널에서 컴파일된 프로그램도 리눅스에서 수행될 수 있도록 personality와 같은 변수를 사용한다.

> 다양한 이진 포맷을 지원하기 위한 필드가 thread_info 내에 존재한다.

##### resource limits
>태스크가 사용할 수 있는 자원의 한계

### 상태 전이와 실행 수준 변화
>태스크가 생성된 뒤, 일을 수행하다 종료될 때 까지의 과정들

![태스크 상태 전이](http://pds24.egloos.com/pds/201205/01/70/a0027070_4f9f41dd56525.jpg)

출처 : [hahaha333.egloos.com](hahaha333.egloos.com)

* 태스크 생성

태스크는 준비상태 (TASK_RUNNING(ready)) 가 된다.

스케줄러는 여러 태스크 중 실행시킬 태스크를 선택하여 수행시킨다.

* 태스크 실행

태스크는 스케줄러에게 CPU를 배정받아 실행상태 (TASK_RUNNING(running))) 가 된다.

* 태스크 종료

태스크가 자신이 할 일을 다 끝내고 exit()를 호출하면(혹은 kill 되거나) TASK_DEAD(EXID_ZOMBIE) 상태로 전이된다.

그러나 자신이 종료된 이유, 자신이 사용한 자원의 통계 정보 등을 부모 태스크에게 알려주기 위해 유지되던 중 부모 태스크가 wait() 등의 함수를 호출하면 자식 태스크는 TASK_DEAD(EXIT_DEAD) 상태로 전이되며 부모는 자식의 종료 정보를 넘겨받게 된다.

그런 뒤 자식 태스크는 자신이 유지하고 있던 자원을 모두 반환하고 최종 종료된다.

* 부모 태스크의 소멸

커널은 고아 태스크의 부모를 init 태스크로 바꾸어 주며(이 떄문에 task_struct 구조체에 real_parent와 parent 라는 2개의 필드가 존재), init 태스크가 wait() 등의 함수를 호출할 떄 최종 소멸된다.

* 태스크 전환

실행 상태의 태스크가 자신에게 할당된 CPU 시간을 모두 사용하였거나, 보다 높은 우선순위를 가지는 태스크로 인해 준비 상태로 전환되는 경우이다.

* 시그널을 받은 태스크

SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU 등의 시그널을 받은 태스크는 TASK_STOPPED 상태로 전이된다.

추후 SIGCONT 시그널을 받아 다시 TASK_RUNNING(ready) 상태로 전환된다.

* 디버깅 되고 있는 태스크

디버거의 ptrace() 호출에 의해 디버깅 되고 있는 태스크는 시그널을 받는 경우 TASK_TRACED 상태로 전이 될 수 있다.

* 특정한 사건을 기다리는 태스크

실행 상태의 태스크가 특정한 사건을 기다려야 할 필요가 있으면 대기상태(TASK_INTERRUPTIBLE, TASK_UNINTERRUPTIBLE, TASK_KILLABLE)로 전이한다.

TASK_UNINTERRUPTIBLE은 시그널에 반응하지 않는다 (예 : KILL -9 PID) 

TASK_UNINTERRUPTIBLE의 문제점을 보안하여 중요한 시그널에만 반응하는 TASK_KILLABLE 상태가 도입되었다.

대기상태로 전이한 태스크는 스케줄러가 호출해 다시 실행(TASK_RUNNING(running))상태가 된다.

### 사용자 수준 실행, 커널 수준 실행

* 사용자 수준 실행(user level running) 상태
> CPU에서 사용자 수준 프로그램의 제작자가 만든 응용 프로그램이나 라이브러리 코드를 수행하고 있는 상태이다.

* 커널 수준 실행(kernel level runnig) 상태
> CPU에서 커널 코드의 일부분을 수행하고 있는 상태로, 사용자 수준 권한보다 강력한 커널 수준 권한으로 동작한다.

#### 사용자 수준 실행에서 커널 수준 실행 상태로 전이

* 시스템 호출의 사용
>태스크가 시스템 호출을 사용하면 리눅스 커널에 트랩이 걸리게 되고 태스크의 상태가 커널 수준 실행 상태로 전이 되며 커널의 시스템 호출 처리 루틴으로 제어가 넘어간다.

* 인터럽트의 발생
>인터럽트가 발생되면 리눅스 커널에 인터럽트가 걸리게 되는데, 이때 실행 중이던 태스크가 사용자 수준에서 동작하고 있었다면 커널 수준 상태로 전이되고, 커널의 인터럽트 처리 루틴으로 제어가 넘어간다.

#### 커널 수준의 실행
>커널 수준에서 실행되는 코드는 리눅스 자체이다.

태스크가 생성되면 리눅스는 task_struct 구조체와 커널 스택을 할당한다.

태스크 당 할당되는 커널 스택은 thread_union 이라 불리며, thread_info 구조체를 포함하고 있다.
[thread_info 설명](https://github.com/Root-kjh/til/blob/master/OS/Linux_Kernel/%ED%83%9C%EC%8A%A4%ED%81%AC_%EA%B4%80%EB%A6%AC.md#format)

