# 태스크 관리

* 태스크 : 자원 소유권의 단위
* 쓰레드 : 수행의 단위
* 프로세스 : 동작중인 프로그램

### 사용자 입장에서의 프로세스 구조

32bit의 운영체제는 각 프로세스에게 총 4GB 크기의 가상공간을 할당한다.

리눅스는 이중 0-3GB를 사용자 공간으로 사용하고, 나머지 3-4GB를 커널 공간으로 사용한다.
(64bit 의 경우 2^64=16EB 크기의 가상 공간 중 약 128TB의 공간을 사용자 공간으로 사용한다.)

![프로세스 구조](https://t1.daumcdn.net/cfile/tistory/2453664C5444038310)
출처 : [ORANG](http://orang.tistory.com/entry/%EB%A6%AC%EB%88%85%EC%8A%A4-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0)

프로세스는 크게 텍스트, 데이터, 스택, 힙이라는 네 영역으로 구분할 수 있다.

텍스트 영역 : CPU에서 직접 수행되는 명령어가 들어가 있다.

데이터 영역 : 전역변수가 들어가있다.

스택 영역 : 지역변수, 인자, 함수의 리턴 주소 등이 존재한다.

힙 영역 : 동적 할당받은 내용이 존재한다.

이떄 각 영역을 세그먼트 혹은 가상 메모리 객체라고 부른다.

### 리눅스의 태스크 모델

프로세스는 자신이 사용하는 자원과 그 자원에서 수행되는 수행 흐름으로 수성된다.

리눅스는 이를 관리하기 위해 task_struct라는 자료구조를 생성한다.

리눅스 커널은 프로세스 와 쓰레드 모두 task_struct로 관리한다.

![리눅스의 태스크 관리 구조](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory&fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F211BEC4C51C727FA2ED4A6)

출처 : [티스토리 블로그](http://muscle-fairy.tistory.com/m/149?category=518502)

이러한 리눅스의 특성은 실제 함수들이 구현된 방식에서도 나타난다.

![태스크 생성과 관계된 함수의 흐름](http://thumbnail.egloos.net/600x0/http://pds22.egloos.com/pds/201205/01/70/a0027070_4f9f3e585b9be.png)

출처 : [egloos 블로그](http://egloos.zum.com/hahaha333/v/3835505)

리눅스에서 사용자의 프로세스 혹은 쓰레드 생성 요청은 라이브러리를 거쳐 시스템 호출을 통해 리눅스 커널에 전달된다.

fork(), vfork(), clone(), pthread_create()는 모두 커널 내부 함수인 do_fork()를 호출한다.

이는 리눅스의 입장에서 쓰레드와 프로세스가 모두 태스크를 생성하기 때문에 가능하다.

즉, do_fork()를 호출할 때, 부모 태스크와 얼마나 공유할지를 정해 줌으로써 fork()와 clone() 함수 둘 다를 지원 할 수 있는 것이다.

#### do_fork()

do_fork() 함수는 새로 생성되는 태스크의 이름표를 준비한다(task_struct) 여기에 태스크에 대한 자세한 정보들을 기록해 둔다.

그 후 태스크에 자원 등을 할당한 뒤 수행 가능한 상태로 만든다.

#### 쓰레드와 프로세스의 차이

fork(), vfork() 함수는 각 태스크의 pid, tgid가 부모 태스크와 서로 다른 것을 알 수 있다.

즉 사용자 입장에서 서로 다른 프로세스가 만들어진 것이다.

반면 pthread_create()에서는 각 태스크의 pid는 다르지만 tgid는 같은것을 알 수 있다.

### 태스크 문맥

태스크는 task_struct 이외에도 많은 정보들이 필요한데, 태스크와 관련된 모든 정보들을 문맥(context)라고 부른다.

![태스크 문맥](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory&fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F171CE23C4F8313E533A370)

출처 : [.NET개발자](http://godffs.tistory.com/m/1446?category=123052)

태스크의 문맥은 크게 세 부분으로 나뉜다.

첫 번째 부분은 시스템 문맥으로 태스크의 정보를 유지하기 위해 커널이 할당한 자료구조들이다.

두 번째 부분은 메모리 문맥으로 텍스트, 데이터, 스택, heap 영역, 스왑 공간 등이 포함된다.

세 번째 부분은 하드웨어 문맥으로 문맥교환 할 때 태스크의 현재 실행 위치에 대한 정보를 유지하며, 실행 중이던 태스크가 대기 상태나 준비 상태로 전이할 때 이 태스크가 어디까지 실행했는지 기억해 두는 공간으로, 이후 이 태스크가 다시 실행될 때 기억해 두었던 곳부터 다시 시작하게 된다.

### task_struct
>task_struct의 변수들

##### task identification
>태스크를 인식하기 위한 변수들 (pid,tgid,해쉬 관련 필드 등), 사용자 접근 권한을 제어하는 변수들 (uid,euid,suid,fsuid 등), 사용자 그룹 접근 제어에 이용되는 변수들(gid,egid,sgid,fsgid 등) 이있다.

##### state
>태스크의 상태를 관리하기 위한 변수
> * TASK_RUNNING(0)
> * TASK_INTERRUPTIBLE(1)
> * TASK_UNINTERRUPTIBLE(2)
> * TASK_STOPPED(4)
> * TASK_TRACED(8)
> * EXIT_DEAD(16)
> * EXIT_ZOMBIE(32)

##### task relationship
> 현재 태스크를 생성한 부모 태스크의 task_struct 구조체를 가리키는 real_parent와 현재 부모 태스크의 task_struct를 가리키는 parent 필드 등이 존재한다.

![task relationship](https://images.slideplayer.com/26/8876622/slides/slide_9.jpg)

출처 : [Kernel Programming Task Management 이병희](https://slideplayer.com/slide/8876622/)

##### scheduling information
> prio,policy,cpus_allowed,time_slice,rt_priority 등 스케줄링과 관련된 변수들이 있다.

##### signal information
>시그널과 관련된 변수들이 존재한다. (시그널은 태스크에게 비동기적인 사건의 발생을 알리는 매커니즘이다.)

##### memory information
>태스크는 자신의 명령어와 데이터를 텍스트, 데이터, 스택, 힙 공간 등에 저장한다.
task_struct에는 이공간에 대한 위치와 크기, 접근 제어 정보 등을 관리하는 변수들이 존재한다.

>가상 주소를 물리 주소로 변환하기 위한 페이지 디렉터리와 페이지 테이블 등의 주소 변환 정보들이 존재한다. 이러한 정보들은 task_struct에서 mm_struct라는 이름의 변수로 접근할 수 있다.

##### file information
>태스크가 오픈한 파일들은 task_struct에서 files_struct 구ㅗ체 형태인 files라는 이름의 변수로 접근할 수 있다.

>루트 디렉터리의 inode와 현재 디렉터리의 inode는 fs_struct 구조체 형태인 fs라는 변수로 접근할 수 있다.

##### thread structure
>쓰레드 구조는 문맥 교환을 수행할 때 태스크가 현재 어디까지 실행되었는지 기억해놓는 공간이다.

##### time information
> 태스크의 시간 정보를 위한 변수, 태스크가 시작된 시간을 가리키는 start_time, real_start_time 등이 있으며, 사용한 cpu 시간의 통계를 담는 필드도 있다.

##### format
> 리눅스는 Linux exec 도메인뿐만 아니라 BSD나 SVR4 커널에서 컴파일된 프로그램도 리눅스에서 수행될 수 있도록 personality와 같은 변수를 사용한다.

> 다양한 이진 포맷을 지원하기 위한 필드가 thread_info 내에 존재한다.

##### resource limits
>태스크가 사용할 수 있는 자원의 한계

### 상태 전이와 실행 수준 변화
>태스크가 생성된 뒤, 일을 수행하다 종료될 때 까지의 과정들

![태스크 상태 전이](http://pds24.egloos.com/pds/201205/01/70/a0027070_4f9f41dd56525.jpg)

출처 : [hahaha333.egloos.com](hahaha333.egloos.com)

* 태스크 생성

태스크는 준비상태 (TASK_RUNNING(ready)) 가 된다.

스케줄러는 여러 태스크 중 실행시킬 태스크를 선택하여 수행시킨다.

* 태스크 실행

태스크는 스케줄러에게 CPU를 배정받아 실행상태 (TASK_RUNNING(running))) 가 된다.

* 태스크 종료

태스크가 자신이 할 일을 다 끝내고 exit()를 호출하면(혹은 kill 되거나) TASK_DEAD(EXID_ZOMBIE) 상태로 전이된다.

그러나 자신이 종료된 이유, 자신이 사용한 자원의 통계 정보 등을 부모 태스크에게 알려주기 위해 유지되던 중 부모 태스크가 wait() 등의 함수를 호출하면 자식 태스크는 TASK_DEAD(EXIT_DEAD) 상태로 전이되며 부모는 자식의 종료 정보를 넘겨받게 된다.

그런 뒤 자식 태스크는 자신이 유지하고 있던 자원을 모두 반환하고 최종 종료된다.

* 부모 태스크의 소멸

커널은 고아 태스크의 부모를 init 태스크로 바꾸어 주며(이 떄문에 task_struct 구조체에 real_parent와 parent 라는 2개의 필드가 존재), init 태스크가 wait() 등의 함수를 호출할 떄 최종 소멸된다.

* 태스크 전환

실행 상태의 태스크가 자신에게 할당된 CPU 시간을 모두 사용하였거나, 보다 높은 우선순위를 가지는 태스크로 인해 준비 상태로 전환되는 경우이다.

* 시그널을 받은 태스크

SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU 등의 시그널을 받은 태스크는 TASK_STOPPED 상태로 전이된다.

추후 SIGCONT 시그널을 받아 다시 TASK_RUNNING(ready) 상태로 전환된다.

* 디버깅 되고 있는 태스크

디버거의 ptrace() 호출에 의해 디버깅 되고 있는 태스크는 시그널을 받는 경우 TASK_TRACED 상태로 전이 될 수 있다.

* 특정한 사건을 기다리는 태스크

실행 상태의 태스크가 특정한 사건을 기다려야 할 필요가 있으면 대기상태(TASK_INTERRUPTIBLE, TASK_UNINTERRUPTIBLE, TASK_KILLABLE)로 전이한다.

TASK_UNINTERRUPTIBLE은 시그널에 반응하지 않는다 (예 : KILL -9 PID) 

TASK_UNINTERRUPTIBLE의 문제점을 보안하여 중요한 시그널에만 반응하는 TASK_KILLABLE 상태가 도입되었다.

대기상태로 전이한 태스크는 스케줄러가 호출해 다시 실행(TASK_RUNNING(running))상태가 된다.

### 사용자 수준 실행, 커널 수준 실행

* 사용자 수준 실행(user level running) 상태
> CPU에서 사용자 수준 프로그램의 제작자가 만든 응용 프로그램이나 라이브러리 코드를 수행하고 있는 상태이다.

* 커널 수준 실행(kernel level runnig) 상태
> CPU에서 커널 코드의 일부분을 수행하고 있는 상태로, 사용자 수준 권한보다 강력한 커널 수준 권한으로 동작한다.

#### 사용자 수준 실행에서 커널 수준 실행 상태로 전이

* 시스템 호출의 사용
>태스크가 시스템 호출을 사용하면 리눅스 커널에 트랩이 걸리게 되고 태스크의 상태가 커널 수준 실행 상태로 전이 되며 커널의 시스템 호출 처리 루틴으로 제어가 넘어간다.

* 인터럽트의 발생
>인터럽트가 발생되면 리눅스 커널에 인터럽트가 걸리게 되는데, 이때 실행 중이던 태스크가 사용자 수준에서 동작하고 있었다면 커널 수준 상태로 전이되고, 커널의 인터럽트 처리 루틴으로 제어가 넘어간다.

#### 커널 수준의 실행
>커널 수준에서 실행되는 코드는 리눅스 자체이다.

태스크가 생성되면 리눅스는 task_struct 구조체와 커널 스택을 할당한다.

태스크 당 할당되는 커널 스택은 thread_union 이라 불리며, thread_info 구조체를 포함하고 있다.

[thread_info 설명](https://github.com/Root-kjh/til/blob/master/OS/Linux_Kernel/%ED%83%9C%EC%8A%A4%ED%81%AC_%EA%B4%80%EB%A6%AC.md#format)

thread_info 안에는 해당 태스크의 task_struct를 가리키는 포인터와, 스케줄링의 필요성 여부를 나타내는 플래그, 태스크의 포맷을 나타내는 exec_domain 등이 존재한다.

![thread_union 구조](http://pds21.egloos.com/pds/201204/15/99/e0107499_4f8a866a1ffe6.png)

출처 : [Brand new JayK](http://jinkyu.tistory.com/87)

태스크가 커널 수준 실행 상태에서 할 일을 모두 마치면 사용자 수준 실행상태로 복귀한다.

그러기 위해 사용자 수준에서의 작업 상황을 어딘가에 저장해 놓아야 한다.

커널로 진입되는 시점에 커널 스택 안에 현재 레지스터의 값을 pt_regs 이름으로 표시된 공간에 구조체를 이용하여 저장한다.

또한 커널은 사용자 실행 수준으로 전이할 때 몇가지 중요한 일들을 처리한다.

1. 커널은 현재 실행중인 태스크가 시그널을 받았는지 확인한다.
>받았다면 필요한 경우에 시그널 처리 핸들러를 호출한다.

2. 다시 스케줄링 해야 할 필요가 있다면(태스크의 need_resched 플래그가 1로 set 되어 있다면) 스케줄러를 호출한다.

3. 커널 내에서 연기된 루틴들이 존재하면 이를 실행한다.

### 런 큐와 스케줄링
>스케줄링 : 여러개의 태스크 중 다음번 수행시킬 태스크를 선택해 CPU를 할당하는 과정

리눅스의 태스크는 실시간 태스크와 일반 태스크로 나뉘며 각각을 위해 별도의 스케줄링 알고리즘이 구현되어 있다.

리눅스가 제공하는 140 단계의 우선순위 중 실시간 태스크는 0-99 단계, 일반 태스크는 100-139 단계 까지를 사용한다.

따라서 실시간 태스크는 일반 태스크보다 항상 우선되어 실행된다.

#### 런 큐와 태스크
>런 큐(Runqueue) : 운영체제가 스케줄링 작업 수행을 위해 수행 가능한 상태의 태스크를 관리하는 자료구조

운영체제에 따라 런큐는 한개에서 여러 개 존재할 수 있다.

##### 태스크의 생성 과정

태스크가 처음 실행되면 init_task를 헤드로 하는 이중 연결 리스트에 삽입된다.

이 중 TASK_RUNNING상태인 태스크는 시스템에 존재하는 런 큐 중 하나에 소속된다.
> 런 큐가 여러개일 경우 일반적으로 부모 태스크가 존재하던 런 큐로 삽입된다.
(더 높은 캐시 친화력을 얻을 수 있기 때문)

대기 상태에서 깨어난 태스크는 대기 전 수행되던 CPU의 런 큐로 삽입된다.
>캐시 친화력 활용

스케줄러가 수행되면 해당 CPU의 런 큐에서 다음번 수행시킬 태스크를 고른다.

![런 큐와 태스크](https://t1.daumcdn.net/cfile/tistory/2535894556F8F37909)

출처 : [Brand new JayK](http://jinkyu.tistory.com/88)

스케줄러가 런 큐에서 실행시킬 태스크를 고를 때 두가지의 고려사항이 있다.

1. 어떤 태스크를 선택할 것인가.
>리눅스는 일반 태스크를 위해 CFS(Completely Fair Scheduler) 를 사용하며, 실시간 태스크를 위해 FIFO, RR, DEADLINE 정책을 제공한다.

2. 런 큐 간의 부하가 균등하지 않은 경우 어떻게 할 것인가.
> 리눅스에서는 부하 균등(load balancing)기법을 제공하며, load_balance()함수가 이를 담당한다.

##### load_balance()

이 함수에서 특정 CPU가 많은 작업을 수행하느라 매우 바쁘고, 다른 CPU들이 한가하다면, 다른 CPU로 태스크를 이주시킨다.

![CPU의 구조](http://image.itdonga.com/files/2016/10/17/001_zqHv6DD.jpg)

출처 : [IT동아](http://it.donga.com/25257/)

만약 1번 Core 에서 태스크를 이주시키려 한다면 같은 캐시를 공유하고 있는 2번 Core에 이주할 것이다.

#### 실시간 태스크 스케줄링(FIFO, RR, DEADLINE)

리눅스는 어떠한 기준에 의거하여 공장하게 태스크를 골라내기 위해 task_struct 필드에 policy, prio, rt-prio 등의 필드가 존재한다.

 * policy
 >이 태스크가 어떤 스케줄링 정책을 사용하는지를 나타낸다.

 리눅스의 실시간 태스크는 FIFO, RR, DEADLINE 정책을 사용하는 태스크를 의미한다.

 태스크를 생성하는 별도의 함수가 존재하지 않고, sched_setscheduler()등의 함수를 통해 태스크의 스케줄링 정책을 바꾸면 실시간 태스크가 된다.

 실시간 태스크는 우선순위 설정을 위해 rt_priority 필드를 사용한다.

 실시간 태스크는 수행을 종료하거나, 스스로 중지하거나, time_slice를 다 쓸 때까지(이 경우는 SCHED_RR 정책만 해당) CPU를 사용한다.

 즉, RR 인 경우 동일 우선순위를 가지는 태스크가 복수개인 경우 타음 슬라이스 기반으로 스케줄링 된다.

 동일 우선순위를 가지는 RR 태스크가 없으면 FIFO와 동일하게 동작한다.

 ##### 실시간 태스크 중 우선순위가 가장 높은 태스크를 찾는 방법

 태스크가 생성되면 그 태스크의 우선순위에 해당하는 비트를 SET 한 뒤, 태스크의 우선순위에 해당되는 큐에 삽입된다.

 사케줄링 하는 시점이 되면 가장 처음으로 SET 되어 있는(우선순위가 가장 높은) 비트를 찾아 낸 뒤, 그 우선순위 큐에 맫라려 있는 태스크를 선택하게 된다.


 ##### DEADLINE 정책
 >가장 급한 태스크를 스케줄 대상으로 선정한다.

 예를들어 동영상을 재생하는 태스크가 수행중이면, 화면을 재생하기 위해 초당 30 프레임을 화면에 출력해야 한다.

 이 태스크는 1초에 30번 해야하는 일을 가지고 있다.

 그 해야하는 일은 적어도 (1초/30번) 보다 적은 시간 내에 수행 될 수 있는 작업량을 가지고 있고, 완료시간이 정해져 있다.

 DEADLINE 정책에서 작업량은 runtime, 완료시간을 deadline 주기성을 period라고 부른다.

 정상적인 동작을 위해 태스크의 runtime과 deadline은 (현재시간 + runtime < deadline) 의 조건을 만족해야 하며, DEADLINE 정책을 사용하는 태스크들의 runtime 합은 CPU의 최대 처리량을 넘을 수 없다.

 새로운 태스크가 DEADLINE 정책을 사용하려 할 때 기존 태스크 들의 runtime과 period를 이용해 태스크의 성공적 완료 여부를 확정할 수 있다.

 실제 스케줄링 기법은 DEADLINE 정책을 사용하는 태스크들은 deadline을 이용하여 RBTree에 정렬되어 있고, 스케줄러가 호출되면 가장 가까운 deadline을 가지는 태스크를 스케줄링 대상으로 선정한다.

 ### 일반 태스크 스케줄링(CFS)

 CFS는 우선순위에 따른 완벽하게 공평한 스케줄링을위해 vruntime 개념을 도입했다.

 각 태스크는 자신만의 vruntime 값을 가지며, 이 값은 스케줄링되어 CPU를 사용하는 경우 사용시간과 우선순위를 고려하여 증가된다.

 리눅스는 주기적으로 발생되는 타이머 인터럽트 핸들러에서 scheduler_tick() 함수를 호출해 현재 수행중인 태스크의 vruntime 값을 갱신한다.

 이 때 vruntime은 (실제 수행시간 * 우선순위 0에 해당하는 weight 값 / 현재 태스크의 우선순위 weight 값) 만큼 증가한다.

 리눅스는 가장 작은 vruntime을 가진 태스크를 다음 스케줄링 대상으로 선정한다.

 각 태스크는 vruntime 값을 키로 해 RBTree에 정렬되어 있다.

 리눅스는 스케줄링이 자주 발생하는것을 막기 위해 타임 슬라이스를 이용한다.
 > 타임 슬라이스 : CPU를 사용할 수 있는시간, 스케줄링간 최소 지연시간 등이 정으되어 있다.

 타임슬라이스는 리눅스가 태스크의 우선순위에 기반해 태스크에게 분배한다.

 스케줄러는 직접적으로 schedule() 함수가 호출되거나, 현재 수행되고 있는 태스크의 thread_info구조체 내부의 flags 필드 중 need_resche 라는 필드가 설정되고 있으면 호출된다.


### 문맥 교환
>수행중이던 태스크의 동작을 멈추고 다른 태스크로 전환하는 과정


* 문맥 저장
>리눅스 커널은 수행중이던 태스크에게 할당되어 있던 타음 슬라이스가 소진되거나, 특정 사건을 기다리기 위해 잠들어야 하는 경우 태스크가 어디까지 수행했는지, 현재 CPU의 레지스터 값 등을 저장해 둔다.

스케줄링이 일어나면 문맥 교환이 발생하고, 문맥 교환 시에 현재 수행중ㅇ던 태스크의 문맥을 저장해야한다.

이런 H/W Context는 task_struct의 struct thread_struct 형태로 정의되어 있다.

만약 A 태스크가 수해 중 B 태스크로 문맥교환이 일어난다면, A태스크가 수행되고 있던 사용자 수준에서 커널 수준으로 상태 전이를 하고, 커널이 수케줄링 코드를 수행하고 다음번 수행 대상으로 Task B를 선정하여 문맥 교회월 하면 지금까지의 CPU 레지스터 정보를 Task A의 task_struct.thread 구조에 저장한다. Task B 역시 Task A의 역순으로 과정을 거치면 문맥 교환이 완료된다.

한번의 문맥교환에 따른 CPU 레지스터 정보 저장/복원은 4번 발생된다.

### 태스크와 시그널
> 시그널 : 태스크에게 비동기적인 사건의 발생을 알리는 메커니즘

사용자가 쉘 프롬프트에서 $ kill PID 명령어를 사용해 특정 PID를 가지고 있는 태스크를 종료시키려 한다면 사용자는 PID를 공유하고 있는 모든 쓰레드들이 종료되기를 기대할 것이다.

따라서 PID가 같은 쓰레드들 간에 시그널을 공유하는 메커니즘이 필요하다.

이렇게 여러 태스크들 사이에 공유해야 하는 시그널이 도착하면 이를 task_struct.singal 필드에 저장해 둔다.

이러한 시그널을 보내는 작업은 sys_kill() 과 같은 시스템 호출을 통해 이뤄진다.

반대로 특정 태스크에게만 시그널을 보내야 하는 경우, 시그널은 task_struct.pending 필드에 저장된다.


각 태스크는 특정 시그널이 발생할 때 수행될 시그널 핸들러(함수)를 지정할 수 있다.

태스크가 지정한 시그널 핸들러는 task_struct.sighand 필드에 저장된다.

또한 특정 시그널을 받지 않도록 task_struct.blocked 필드를 통해 설정할 수 있다.
>시그널 중 SIGKILL, SIGSTOP 시그널은 무시할 수 없다.

##### 시그널을 보내는 과정

1. 해당 태스크의 task_struct 구조체를 찾아낸다.
2. 보내려는 시그널 번호를 통해 siginfo 자료 구조를 초기화 한다.
3. 시그널의 성격에 따라 task_struct의 signal이나 pending 필드에 매달아 준다.
4. 이 때 blocked 필드를 검사하여 무시하도록 설정한 시그널인지 검사한다.

수신한 시그널의 처리는 태스크가 커널수준에서 사용자 수준 실행 상태로 전이될 때 이루어진다.

커널은 pending. singal 필드를 검사해 처리를 대기중인 시그널을 확인하고, 시그널이 블록되어 있지 않다면 시그널 번호에 해당되는 시그널 핸들러를 sighand.action 배열에서 찾아 수행시킨다.

만약 태스크가 핸들러를 등록하지 않은경우, 커널은 디폴트 액션을 취하게 된다.

**인터럽트, 트랩, 시그널의 차이**

인터럽트, 트랩 : 사건의 발생을 커널에게 알림

시그널 : 사건의 발생을 태스크에게 알림