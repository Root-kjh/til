## 메모리 관리

### 메모리 관리 기법과 가상 메모리
>물리 메모리의 한계를 극복하기 위해 나온 기법 중 가장 성공적인 기법

#### 가상 메모리
>실제 시스템에 존재하는 물리 메모리의 크기와 관계없이 가상 주소 공간을 사용자 태스크에게 제공한다.

32bit CPU의 경우 주소 지정할 수 있는 최대 크기인 2^32 크기(4GB)를 제공하며,
64bit CPU의 경우 2^64 크기(16EB)의 크기를 제공한다.

4GB의 공간은 프로그래머에게 제공되는 가상의 공간이며, 실제로는 사용자가 필요한 만큼의 물리 메모리를 제공한다.

### 물리 메모리 관리 자료 구조

복수 개의 CPU를 가지고 있는 컴퓨터 시스템 중 모든 CPU가 메모리와 입출력 버스 등을 공유하는 구조를 SMP라 부른다.

CPU들을 몇 개의 그룹으로 나누고 각각의 그룹에게 별도의 지역 메모리를 주는 구조를 NUMA라 부르며, 기존 시스템을 UMA라 한다.

NUMA 구조에서는 CPU에서 어떤 메모리에 접근 하느냐에 따라 성능의 차이가 생길 수 있다.

예를 들어 CPU를 자신에게 가까운 곳의 메모리를 주로 사용해야 빠르게 데이터를 읽어올 수 있다.

즉, 각각의 구조에 적합한 메모리 정책을 사용해야 한다.

#### Node
>뱅크를 표현하는 구조

**뱅크(Bank)**
>리눅스에서 접근 속도가 같은 메모리의 집합

만약 NUMA 구조의 시스템에서 리눅스가 수행되면 복수 개의 노드가 존재할 것이고, UMA 구조의 시스템에서는 한 개의 노드가 존재할 것이다.

복수 개의 노드는 리스트를 통해 관리되며, pgdat_list 배열을 통해 접근 가능하다.
![Bank와 Node의 관계](https://t1.daumcdn.net/cfile/tistory/2279804D553B7CBC01)

출처 : [A.T.S Mucha](http://atsequence.tistory.com/30)

하나의 노드는 pg_data_t 구조체를 통해 표현된다.

이 구조체는 해당 노드에 속해있는 물리 메모리의 실제 양(node_present_pages), 해당 물리메모리가 메모리 맵의 몇 번지에 위치하고 있는지를 나타내기 위한 변수(node_start_pfn) 등이 정의되어 있다.

만약 리눅스가 물리 메모리의 할당을 요청 받게 되면, 되도록 할당을 요청한 태스크가 수행되고 있는 CPU와 가까운 노드에서 메모리를 할당하려 한다.

이러한 이유 때문에 이전에 수행되었던 CPU에서 다시 수행되도록 하는 정책이 높은 성능을 얻게 된다.

#### Zone
>Node의 일부분을 따로 관리 할 수 있게 만든 자료구조

다른 Zone의 메모리와는 별도로 관리되어야 하는 메모리의 집합이다.

* ZONE_DMA
>16MB 이하

* ZONE_NORMAL
>16MB 이상

* ZONE_HIGHMEN
>896BM 이상

#### Page Frame
>각각의 zone은 자신에 속해 있는 물리 메모리 들을 관리하는데, 이 물리 메모리의 최소 단위를 Page Frame 이라 한다.

![Zone과 Page Fraem](https://t1.daumcdn.net/cfile/tistory/21096236553B84CE0C)

출처 : [A.T.S Mucha](http://atsequence.tistory.com/30)



복수 개의 Page Frame -> Zone

복수 개의 Zone -> Node

### Buddy, Slab

리눅스의 메모리 최소 할당 단위는 페이지 프레임 단위인 4KB이다.
>할당된 공간마다 메타 데이터로 관리 할 때 합리적인 최소 할당 공간

#### 버디 할당자(Buddy Allocator)
>2.6.19 버전 이전의 메모리 할당자, 현재는 Lazy Buddy Allocator가 쓰인다.

버디 할당자는 zone 구조체에 존재하는 free_area() 배열을 통해 구축된다.

free_area 배열의 각 엔트리는 free_area 라는 구조체이며, free_list, map 이라는 필드를 갖는다.

free_area 배열은 10개의 엔트리를 가진다 0~9까지 각각의 숫자는 해당 free_area가 관리하는 할당의 크기를 나타낸다.
예를들어 0인 2^0, 1인경우 2^1로 각각 1개의 페이지 프레임, 2개의 페이지 프레임이 할당되는 단위이다.

결국 버디는 2^n 의 페이지 프레임들을 할당해준다.

free_area 구조체는 free_list 변수를 통해 자신에게 할당된 free 페이지 프레임들을 list로 관리한다.

또한 자신이 관리하는 수준에서 페이지의 상태를 map 변수를 통해 비트맵으로 관리한다.

![버디 할당자의 동작 예](https://t1.daumcdn.net/cfile/tistory/2403073752468D3939)

출처 : [Daeseok's Blog](http://woodz.tistory.com/57)

