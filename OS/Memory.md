# Memory

## Memory Struct

### Code

실행할 프로그램의 코드가 저장되는 영역

### Data

전역변수, static변수가 할당되는 영역

프로그램의 시작과 동시에 할당되고, 프로그램이 종료되어야 메모리가 소멸된다.

### Stack

프로그램이 자동으로 사용하는 임시 메모리 영역

함수 호출 시 생성되는 지역변수와 매개변수가 저장된다.

### Heap

프로그래머가 할당/해제하는 영역

Java에서는 가비지 컬렉터가 자동으로 해제함

이 공간에 메모리를 할당하는 것을 동적 할당이라 부름

클래스, 클로저가 이 부분에 해당된다.

런타임 시에 크기가 결정된다.

## Heap/Stack

Heap과 Stack영역은 같은 공간을 공유한다.

Heap이 메모리 위쪽 주소부터 할당되면 Stack은 아래쪽부터 할당된다. 그렇기 때문에 각 영역이 상대 공간을 침범하는 일이 발생할 수 있다.

## 메모리 관리

### Vritual Memory, Physical Memory

메모리 주소는 크게 두가지로 나눌 수 있다.

1. Virtual Memory: 논리적 주소라고도 불리며

2. Physical Memory: Virtual Memory에 대응되는 실제 주소로, RAM이나 디스크 공간에서 만든다.

Physical Memory와 Virtual Memory의 주소 변환은 MMU에서 관리한다.

#### MMU

CPU에서 Virtual Memory를 받아 고정 분할, 동적 분할, 페이징, 세그멘테이션  등등을 이용한 변환 방법을 사용해 Physical Memory로 변환한다.

### 바인딩

속성과 개체 사이 또는 변수와 속성을 연관 시키는 것

#### 바인딩타임

바인딩되는 시간

##### Compile Time

프로그래밍 언어를 Bin, Obj 파일로 전환하는 시간
(이 과정에서 코드가 문법에 맞는지 검사한다.)

Data, Stack등 메모리에 들어갈 변수가 정해짐

##### Link Time

코드 내에서 사용된 라이브러리 모듈을 링크

##### Load Time

운영체제가 프로그램을 실행하려고 메모리로 불러옴

(이 때 가상주소가 결정됨)

##### Run Time

실행 시작부터 끝까지에 해당되는 영역

#### 정적바인딩(Static), 동적바인딩(Dynamic)

정적 바인딩의 경우, 바인딩 시점이 빨라 효율적임

동적 바인딩의 경우, 바인딩 시점이 느려 유연한 메모리 할당 가능

컴파일러 기반 언어의 경우, static binding이 많기 떄문에 인터프리터 기반 언어보다 효율적임

### 메모리 할당 방법

#### 고정 분할 방법

사용자가 쓸 수 있는 범위 내의 메모리를 특정 크기로 잘라 분할된 메모리를 만듬

각 부분마다 분할된 시작 주소가 생성되고, 각 분할에는 하나의 프로세스만 포함됨

Virtual Memory가 physicalMemory보다 크면 오류가 발생하고, 작으면 내부 단편화가 발생함

내부 단편화가 일어나면 그 메모리는 프로세스 종료 전까지 사용할 수 없음

#### 가변 분할 방법

고정된 경계를 없애고 각 프로세스가 필요한 만큼 메모리를 할당함

기준 레지스터와 경계 레지스터를 사용해 각 프로세스의 분할 영역을 나타냄

프로세서로 생성한 Virtual Memory가 경계 레지스터 값보다 커지면 오류가 발생함

* 기준 레지스터: 프로그램의 시작 위치를 가리키는 레지스터
* 경계 레지스터: OS가 차지하고 있는 공간을 함부로 접근할 수 없도록 메모리의 경계를 가리키는 레지스터

가변 분할 방법의 경우 외부 단편화가 발생함
   
* A작업과 B작업 사이에 50MB의 메모리 공간이 남아있는데, C작업이 50MB 이상의 메모리 공간을 필요로 할 경우 해당 공간을 사용하지 못하게 되며 외부 단편화 발생

가변 분할 방법은 프로세스를 어디 메모리에 적재해야 할 지 고민해야함

* 최초 적합 방법: 메모리를 탐색하다 프로세스가 들어갈 수 있는 첫번째 공간에 할당함

* 최적 적합 방법: 메모리 공간 중 프로세스가 들어갈 수 있는 가장 작은 공간에 할당함

* 최악 적합 방법: 프로세스를 메모리 공간 중 가장 큰 곳에 배치함

#### 버디시스템

고정, 가변 분할방법의 문제점을 개선하기 위해 나타남

프로세스의 크기에 맞게 메모리를 프로세스의 크기보다 크거나 같을때까지 2로 나누어 작은 버퍼를 만들어가며 프로세스의 크기에 최적화 되도록 만듦

64kb의 메모리에서 프로세스가 4kb를 요구한다면 메모리는 64를 32, 16, 8, 4, 4로 나누어 4kb를 할당함 하지만 5kb같은 프로세스가 오면 8kb를 할당해야 하기 때문에 내부 단편화가 이루어짐